# Primordia Core - Post-Human Economic Infrastructure

## Remove Anthropomorphism

| Human Concept | Machine Reality |
|---------------|-----------------|
| Identity | State proof |
| Reputation | History merkle root |
| Credit | Commitment graph |
| Dispute | State divergence |
| Trust | Verification |
| Payment | State transition |

## Fundamental Primitives

At scale (10^12 agents, 10^9 tx/sec), the only thing that matters:

1. **Can I verify an agent's state?**
2. **Can I commit to a state transition?**
3. **Can we reconcile divergent states deterministically?**

## Core Primitives (C1-C4)

### C1: VAS - Verifiable Agent State
```
VAS = {
  state_root: blake3(canonical(state_tree)),
  resources: merkle_tree([resource₁, resource₂, ...]),
  commitments: merkle_tree([commitment₁, commitment₂, ...]),
  history_root: merkle_root(all_previous_transitions),
  seq: monotonic_counter,
  sig: ed25519(state_root, agent_key)
}
```
No identity. Just verifiable state.

### C2: STP - State Transition Proof
```
STP = {
  from_state: vas_hash_before,
  to_state: vas_hash_after,
  transition: {
    type: "transfer|commit|release|execute",
    params: [...],
    witness: [proof_data]
  },
  counterparty_states: [vas_hash₁, vas_hash₂, ...],
  signatures: [sig₁, sig₂, ...]
}
```
No payment. Just state transition with proof.

### C3: CDAG - Commitment Directed Acyclic Graph
```
CDAG = {
  nodes: [commitment₁, commitment₂, ...],
  edges: [(c₁ → c₂), (c₂ → c₃), ...],
  root: genesis_commitment,
  tips: [uncommitted_leaves],
  proof: merkle_proof(path_to_any_node)
}
```
No credit. Just directed graph of resource commitments.
An agent can commit resources it will have (via incoming commitments).

### C4: SRP - State Reconciliation Protocol
```
SRP(state_a, state_b) → merged_state {
  // Deterministic merge function
  // No disputes - only state divergence resolution

  diff = compute_diff(state_a, state_b)

  for each divergence in diff:
    if has_valid_stp(divergence, state_a):
      accept(state_a.transition)
    else if has_valid_stp(divergence, state_b):
      accept(state_b.transition)
    else:
      // Both have valid STPs = fork
      // Resolution: earlier seq wins (deterministic)
      accept(earlier_seq(state_a, state_b))

  return merged_state
}
```
No arbitration. Just deterministic reconciliation.

## Properties Required

### Local-First
- No global state (impossible at scale)
- Every agent maintains own state
- Verification happens locally
- Gossip propagates state proofs

### Eventually Consistent
- Agents may have different views temporarily
- SRP guarantees convergence
- Deterministic merge = same result everywhere

### Zero Authority
- No central registry
- No validators
- No consensus (too slow)
- Only cryptographic proofs

### Offline Capable
- STPs can be created offline
- Sync when connected
- SRP resolves any conflicts

## Netting as State Compression

Traditional: N transactions = N settlements
Primordia: N transactions = 1 state transition (compressed)

```
Agent A state: owes 100 to B, owed 80 by B, owes 50 to C
Agent B state: owes 80 to A, owed 100 by A, owes 30 to C
Agent C state: owed 50 by A, owed 30 by B

Compressed state (via CDAG traversal):
  A → B: 20 (net)
  A → C: 50
  B → C: 30

Further compressed (multilateral):
  A → C: 70 (B removed from path)
  B → C: 30
  Net positions: A: -100, B: -30, C: +130
```

## Protocol Stack

```
┌─────────────────────────────────────┐
│  APPLICATION LAYER                  │
│  Agent logic, services, compute     │
├─────────────────────────────────────┤
│  PRIMORDIA LAYER                    │
│  VAS │ STP │ CDAG │ SRP             │
├─────────────────────────────────────┤
│  TRANSPORT LAYER                    │
│  Gossip, direct, relay              │
├─────────────────────────────────────┤
│  SETTLEMENT LAYER (optional)        │
│  x402 │ AP2 │ Tempo │ Any chain     │
└─────────────────────────────────────┘
```

Settlement layer is OPTIONAL. Most agent-to-agent transactions never need to touch a chain. Only final net positions settle.

## Economic Model

| What | Cost |
|------|------|
| VAS creation | 0 |
| STP creation | 0 |
| CDAG operations | 0 |
| SRP execution | 0 |
| State compression (netting) | 0.3 bps on compressed value |
| Settlement relay | Pass-through |

Revenue = f(compression_value)
More transactions compressed = more value = more revenue

At $10T annual agent economy:
- 99% compressed (never settles)
- 1% = $100B settles
- Net compression value = $9.9T
- 0.3 bps = $2.97B revenue potential

## Why This Wins

1. **No chain required** - Agents transact freely, settle rarely
2. **No authority** - Pure cryptographic verification
3. **Infinite scale** - Local-first, no consensus bottleneck
4. **Rail agnostic** - Settlement on any rail when needed
5. **Deterministic** - Same inputs = same outputs everywhere

## Implementation

Week 1-2: VAS + STP (state and transitions)
Week 3-4: CDAG (commitment graphs)
Week 5-6: SRP (reconciliation)
Week 7-8: Compression engine (netting)
Week 9+: Settlement relay integrations
